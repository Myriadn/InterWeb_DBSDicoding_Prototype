/* eslint-disable no-restricted-globals */
// Import Workbox libraries
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, setCatchHandler, setDefaultHandler } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Cache names
const APP_SHELL_CACHE = 'story-app-shell-v1';
const CONTENT_CACHE = 'story-app-content-v1';
const IMAGE_CACHE = 'story-app-images-v1';
const STATIC_CACHE = 'story-app-static-v1';
const FONT_CACHE = 'story-app-fonts-v1';

// Bersihkan cache yang sudah tidak digunakan
cleanupOutdatedCaches();

// Precache all assets generated by webpack
precacheAndRoute(self.__WB_MANIFEST);

// Additional app shell files that might not be in the webpack manifest
const additionalAppShellFiles = [
  '/offline.html',
  '/favicon.png',
  '/manifest.json',
  '/images/logo.png',
];

// Static assets - CSS, JS libraries, fonts
const STATIC_ASSETS = [
  'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
  'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
  'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css',
  'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/webfonts/fa-solid-900.woff2',
  'https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap',
];

// PWA icons - sesuai dengan manifest.json
const PWA_ICONS = [
  '/images/icons/maskable_icon_x48.png',
  '/images/icons/maskable_icon_x72.png',
  '/images/icons/maskable_icon_x96.png',
  '/images/icons/maskable_icon_x128.png',
  '/images/icons/maskable_icon_x192.png',
  '/images/icons/maskable_icon_x384.png',
  '/images/icons/maskable_icon_x512.png',
  '/images/icons/add-x512.png',
  '/images/icons/bookmark-x512.png'
];

// Background sync for post requests
const bgSyncPlugin = new BackgroundSyncPlugin('story-queue', {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (specified in minutes)
});

// Cache additional app shell files
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(APP_SHELL_CACHE)
      .then((cache) => {
        console.log('Caching additional app shell files');
        return cache.addAll([...additionalAppShellFiles, ...PWA_ICONS]);
      })
      .then(() => self.skipWaiting())
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    // Claim client untuk kontrol yang lebih cepat
    self.clients.claim()
  );
});

// Route for App Shell - HTML navigation requests
registerRoute(
  ({ request }) => 
    request.mode === 'navigate' || 
    (request.method === 'GET' && request.headers.get('accept')?.includes('text/html')),
  new NetworkFirst({
    cacheName: APP_SHELL_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
    networkTimeoutSeconds: 3,
  })
);

// Fallback to offline page untuk navigasi yang gagal
const navigationHandler = async (params) => {
  try {
    // Attempt to get the resource from the network
    return await new NetworkOnly().handle(params);
  } catch (error) {
    // If catch handler threw an error, try to get the offline shell
    return caches.match('/offline.html');
  }
};

// Route for API requests
registerRoute(
  ({ url }) => 
    url.href.includes('/api/') || 
    url.href.includes('dicoding.com/api') || 
    url.href.includes('story-api.dicoding.dev'),
  new NetworkFirst({
    cacheName: CONTENT_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
    networkTimeoutSeconds: 5,
  })
);

// Route for POST requests with background sync
registerRoute(
  ({ url, request }) => 
    (url.href.includes('/api/') || url.href.includes('story-api.dicoding.dev')) && 
    request.method === 'POST',
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  })
);

// Route for web fonts (faster loading and better offline experience)
registerRoute(
  ({url, request}) => 
    request.destination === 'font' ||
    url.href.includes('fonts.googleapis.com') || 
    url.href.includes('fonts.gstatic.com'),
  new CacheFirst({
    cacheName: FONT_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Route for static assets
registerRoute(
  ({ request, url }) => {
    return STATIC_ASSETS.some(asset => url.href.includes(asset));
  },
  new StaleWhileRevalidate({
    cacheName: STATIC_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Route for images - Optimized caching with resizing
registerRoute(
  ({ request }) => request.destination === 'image' || request.url.match(/\.(jpe?g|png|gif|svg|webp)$/i),
  new CacheFirst({
    cacheName: IMAGE_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
    fetchOptions: {
      cache: 'no-cache',
    },
    matchOptions: {
      ignoreSearch: true,
    },
  })
);

// Default route for everything else
registerRoute(
  ({ request }) => request.destination === 'script' || 
                  request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: STATIC_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Set default handler dan catch handler
setDefaultHandler(new NetworkOnly());

// Catch handler untuk saat offline (fallback)
setCatchHandler(async ({ event }) => {
  // IMPORTANT: Clone the request. A request is a stream and
  // can only be consumed once.
  const { request } = event;
  const destination = request.destination;

  switch (destination) {
    case 'document':
      return caches.match('/offline.html');
    case 'image':
      return caches.match('/images/placeholder-image.jpg');
    default:
      // If we don't have a fallback, just return an error response.
      return Response.error();
  }
});

// Push notification event
self.addEventListener('push', (event) => {
  let notificationData;

  try {
    notificationData = event.data.json();
  } catch (e) {
    // Jika format data bukan JSON, gunakan text
    notificationData = {
      title: 'Story App Notification',
      options: {
        body: event.data ? event.data.text() : 'Ada story baru!',
      },
    };
  }

  // Pastikan data notifikasi sesuai format yang diharapkan
  const title = notificationData.title || 'Story App Notification';
  const options = notificationData.options || {
    body: 'Ada cerita baru untuk Anda!',
  };

  // Tambahkan properti tambahan ke options
  options.icon = '/favicon.png';
  options.badge = '/favicon.png';
  options.vibrate = [100, 50, 100];
  options.data = {
    dateOfArrival: Date.now(),
    primaryKey: 1,
    url: '/'
  };
  options.actions = [
    {
      action: 'explore',
      title: 'Lihat Cerita',
    },
    {
      action: 'close',
      title: 'Tutup',
    },
  ];

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Notification click event
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'explore' || !event.action) {
    const urlToOpen = event.notification.data.url || '/';
    
    event.waitUntil(
      clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((windowClients) => {
          // Cek apakah sudah ada jendela yang terbuka
          for (let i = 0; i < windowClients.length; i++) {
            const client = windowClients[i];
            if (client.url.includes(urlToOpen) && 'focus' in client) {
              return client.focus();
            }
          }
          
          // Jika tidak ada jendela yang terbuka, buka jendela baru
          if (clients.openWindow) {
            return clients.openWindow(urlToOpen);
          }
        })
    );
  }
});